}
data<- x$get()
m<- mean(data, ...)
x$setmean(m)
m
}
mv<- makeVector(1:5)
cachemean(mv)
mv1<- makeVector(1:10)
cachemean(mv1)
cachemean(mv)
cachemean(mv1)
A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,4)
A <- matrix(c(4,4,-2,2,6,2,2,8,4,1,2,3),3,4)
A
B<- solve(A)
makeCacheMatrix <- function(x = matrix()) {
MI<- NULL
set<- function(y){
x<<- y
MI<<- NULL
}
get<- function(){x}
setinverse<- function(matinverse){MI<<- matinverse}
getinverse<- function(){MI}
list(set= set, get=get, setinverse= setinverse, getinverse=getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
MI<- x$getinverse()
if(!is.null(MI)){
message("getting cached data")
return(MI)
}
dm<- x$get()
MI<- solve(dm, ...)
x$setinverse(MI)
MI
}
A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)
cacheSolve(A)
A
A<- null
A<- NULL
A
A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)
M<- makeCacheMatrix(A)
cacheSolve(M)
cacheSolve(M)
## This file already contained the stub 1.makeCacheMatrix and 2.cacheSolve.
## Assignment is to implement the pair of functions such that it can cache the inverse of a matrix
## Most of the comments in this file is thanks due to a clear explanation and comments by Bill Hilton
## in a forum discussion thread Making sense of Assignment 2
## makeCacheMatrix: This function creates a special "matrix" object that can cache its inverse.
## We are taking a function and converting it into an R object (class more specifically).
## This object is a container which holds the created matrix and the variable MI which is initialized to NULL.
makeCacheMatrix <- function(x = matrix()) {   ## Calling makeCacheMatrix will create an object of type matrix,
##with variable MI initialized to NULL.
MI<- NULL
set<- function(y){  # takes an input matrix
x<<- y            # saves the input matrix
MI<<- NULL        # resets the mean to NULL.
}
get<- function(){x}  # this function returns the value of the original matrix
setinverse<- function(matinverse){MI<<- matinverse} # this is called by cacheSolve() during the first cacheSolve() access
#and it will store the value using superassignment
getinverse<- function(){MI}             # this will return the cached value to cacheSolve() on subsequent accesses
list(set= set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## cacheSolve returns a matrix that is the inverse of 'x'
## The second function, cacheSolve(x) When called, first gets the inverse from the object x (x$getinverse()).
## If there is a non-NULL value in the inverse then a message is sent and the inverse is returned and the cacheSolve function stops.
## If the fetched inverse value is NULL then the if() statement is skipped and the next four lines are executed,
## namely a fetch of the original matrix (x$get()), calculation of the inverse of that matrix,
## storing this inverse value back in the object (x$setinverse(MI)) and the return of MI to end the function.
cacheSolve <- function(x, ...) {  # the input x is an object created by makeCacheMatrix
MI<- x$getinverse()     # accesses the object 'x' and gets the inverse of the matrix
if(!is.null(MI)){       # if inverse was already cached (not NULL)...
message("getting cached data")  # ... send this message to the console
return(MI)            # ... and return the inverse ... "return" ends
}
dm<- x$get()            # we reach this code only if x$getinverse() returned NULL
MI<- solve(dm, ...)     # if MI was NULL then we have to calculate the inverse
x$setinverse(MI)        # store the inverse matrix in x
MI                      # return the inverse matrix to the code that called this function
}
A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)
M<- makeCacheMatrix(A)
cachesolve(M)
cacheSolve(M)
cacheSolve(M)
install packages("swirl")
install.packages("swirl")
library(swirl)
ls()
rm(list=ls())
swirl()
5+7
x<- 5+7
x
y<- x-3
y
z<- c(1.1,9,3,14)
z<- c(1.1,9,3.14)
?c
z
c(z,555,z)
z*2+100
my_sqrt<- sqrt(z-1)
my_sqrt
my_div<- z/my_sqrt
my_div
c(1,2,3,4)+c(0,10)
c(1,2,3,4)+c(0,10,100)
z*2+1000
my_div
bye()
library(swirl)
ls()
rm(list=ls())
swirl()
1:20
pi:10
15:1
?`:`
seq(1,20)
seq(0,10, by=0.5)
my_seq<- seq(5,10, length=30)
length(my_seq)
1:length(my_seq)
seq(along.with=my_seq)
seq_along(my_seq)
rep(0,times=40)
rep(c(0,1,2), times=10)
rep(c(0,1,2), each=10)
num_vect<- c(0.5,55,-10,6)
tf<- num_vect<1
tf
num_vect>=6
my_char<- c("My", "name", "is")
my_char
paste(my_char, collapse=" ")
my_name<- c(my_char,"naveen")
my_name
paste(my_name, " ")
paste(my_name, collapse=" ")
paste("Hello", "world!", sep=" ")
paste(c(1:3), c("X","Y","Z"), sep="")
paste(LETTERS, 1:4, sep="-")
x<- c(44,NA,5,NA)
x*3
y<- rnorm(1000)
z<- rep(NA, 1000)
my_data<- sample(c(y,z),100)
my_na<- is.na(my_data)
my_na
my_data==NA
sum(my_na)
my_data
0/0
Inf-Inf
x
x[1:10]
x[is.na(x)]
y<- x[!is.na(x)]
y
y[y>0]
x[x>0]
x[!is.na(x)&x>0]
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect<- c(foo=11, bar=2, norf=NA)
vect
names(vect)
vect2<- c(11,2,NA)
names(vect2)<- c("foo", "bar", "norf")
identical(vect, vect2)
vect["bar"]
vect[c("foo", "bar")]
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
a
apply(a, c(1, 2), mean)
rnorm(1, 1, 2)
rnorm(1, 1, 2)
rnorm(3, 1, 2)
mean(3.785957, -1.455778)
mean(3.785957, -1.455778, 3.170316)
mean(-1.455778, 3.170316)
mean(-1.455778)
?rnorm
library(datasets)
data(iris)
?iris
d<- dimnames(iris)
d
stru(iris)
str(iris)
iris
library(datasets)
data(iris)
iris
df<- iris
sub_df<- split(df, df["Species"])
sub_df
sub_df$virginica
sub_df$virginica{"Sepal.Length"}
sub_df$virginica["Sepal.Length"]
mean(sub_df$virginica["Sepal.Length"])
m<- sapply((sub_df$virginica["Sepal.Length"]), mean)
m
runif(sample(1:10, 1))
runif(sample(1:10, 1))
?runif
lapply(mtcars, class)
unlist(lapply(mtcars, class))
?which
which(LETTERS == "R")
?extract
?EXTRACT
myvars <- paste('V', 1:9, sep='')
myvars
myname <- paste('Naveen','Rao', sep='')
myname
myname <- paste('Naveen','Rao', sep=' ')
myname
myname[c(2)]
myname[[2]]
myname[1]
str(myname)
class(myname)
nums <- seq(-1, 1, by=.01)
nums
nums <- seq(1, -1, by=.01)
nums <- seq(1, -1, by=-.01)
nums
nums <- seq(-1, 1, by=.01)
ans <- numeric(length(nums))
ans
nums <- seq(-1, 1, by=.01)
ans <- numeric(length(nums))
for(i in seq(along=nums)) ans[i] <- nums[i]^2
ans[2]
nums <- seq(-1, 1, by=.01)
ans <- NULL
for(i in nums) ans[i] <- i^2
ans[2]
nums <- seq(-1, 1, by=.01)
ans <- NULL
for(i in length(nums)) ans[i] <- i^2
ans[2]
nums <- seq(-1, 1, by=.01)
ans <- NULL
for(i in seq_along(nums)) ans[i] <- i^2
ans[2]
ans[3]
matrix(15:1, 3)
apply(matrix(15:1, 3), 1, sort)
apply(matrix(15:1, 3), 2, sort)
t(apply(matrix(15:1, 3), 1, sort))
factor(1, levels=1:2)
xlis <- list(A=1:4, B=c('a', 'x'))
xlis
c(xlis, C=6:5)
c(xlis, list(C=6:5))
nam <- c(4, 7)
vec <- rep(0, length(nam))
nam
vec
?rpois
1
n<- 10
1:n-1
1:(n-1)
df<- data.frame(v=1:4,ch=c("a","B","c","d"),n=10)
df
list(a=c(1,2),b="hi",c=3i)
rep(4,3)
rep(1:4,3)
seq(along=5)
seq(5,100, by=5)
seq(from=5, length=5)
list(a=c(1,2),b="hi",c=3i)
lt<- list(a=c(1,2),b="hi",c=3i)
lt[2]
lt[[2]]
lt[[1]]
lt[1]
lt$a
lt$b
lt[["b"]]
lt[["2"]]
AllData
ts<- c(1,2,3,4)
colnames(ts)<- c("one","two","three","four")
ts
Month    <- c(11,  7,  7,   NA,  9,     9,  11)
LengthCT <- c(75, 85, 91.6, 95, NA, 105.5, 106)
Tb       <- c( 0,  0,  1,   NA,  0,   0,     0)
Boar <- cbind(Month, LengthCT, Tb)
Boar[,1]
dim(Boar)
nrow(Boar)
Tb2 <- vector(length = 7)
Tb2
D<- matrix(nrow=3, ncol=3)
D
D<- cbind(c(1,4,2),c(2,2,3),c(3,1,0))
D
DI<- solve(D)
DI
TD<- t(D)
TD
DM<- D%*%DI
DM
D%*% solve(D)
setwd<- "C:\Users\innarao\Documents\Coursera"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
download.file(fileUrl, destfile="test.csv")
list.files()
list.files("./coursera")
df<- read.csv("test.csv")
df
df(head=3)
names(df)
header(df)
df("header")
df(nrows=2)
head(df)
nrows(df)
nrow(df)
nrow(df, "VAL">100000)
nrow(df$VAL>100000)
nrow(df$VAL>100000, na.rm=TRUE)
nrow(df$VAL>=24)
setwd<- "C:/Users/innarao/Documents/Coursera"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile="test.xlsx")
df1<- read.table("test.xlsx")
head(df1)
setwd<- "C:/Users/innarao/Documents/Coursera"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile="./coursera/test.xlsx")
df1<- read.table("./coursera/test.xlsx")
names(test.xlsx)
names("test.xlsx")
names("./coursera/test.xlsx")
library(xlsx)
package(xlsx)
load(xlsx)
library(xlsx)
packages()
package()
library()
install.packages(xlsx)
install.packages("xlsx")
library(xlsx)
library()
library()
install.packages("xlsx")
install.packages("xlsx")
install.packages("xlsxjars")
install.packages("XML")
library(XML)
install.packages("RMySQL")
source("http://bioconductor.org/biocLite.R")
biocLite("rhdf5")
library()
install.packages("XML")
system.time(x <- c()
for(i in 1:200000){
if(i %% 2 == 0){
x <- c(x, i)
}
})
x <- c()
system.time(
for(i in 1:200000){
if(i %% 2 == 0){
x <- c(x, i)
}
})
a <- 1:200000
system.time(x <- a[a %% 2 == 0])
x
a <- 1:200000
system.time(y <- a[a %% 2 == 0])
x
y
? apply
x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(x)[[1]] <- letters[1:8]
x
x3 = c(4:1, 2:5)
x3
y <- rbind(x1 = 3, x2 = c(4:1, 2:5))
> dimnames(y)[[1]] <- letters[1:8]
x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(x)[[1]] <- letters[1:8]
y <- cbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(y)[[1]] <- letters[1:8]
y
y <- rbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(y)[[1]] <- letters[1:8]
y <- rbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(y)[[1]] <- letters[1:8]
y <- rbind(x1 = 3, x2 = c(4:1, 2:5))
y
y <- rbind(x1 = 3, x2 = c(4:1, 2:5)); dimnames(y)[[,1]] <- letters[1:8]
y <- rbind(x1 = 3, x2 = c(4:1, 2:5)); colnames(y)[[,1]] <- letters[1:8]
col.sums<- apply(x,2,sum)
col.sums
row.sums<- apply(x,1,sum)
row.sums
aggregate
?aggregate
?summayBy
?summaryBy
M <- array( seq(32), dim = c(4,4,2))
M
con = url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en")
htmlCode = readLines(con)
close(con)
htmlCode
library(httr); html2 = GET(url)
content2 = content(html2,as="text")
parsedHtml = htmlParse(content2,asText=TRUE)
xpathSApply(parsedHtml, "//title", xmlValue)
library()
library(httr)
BROWSE("http://had.co.nz")
library(httr)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html2 = GET(url)
content2 = content(html2,as="text")
parsedHtml = htmlParse(content2,asText=TRUE)
xpathSApply(parsedHtml, "//title", xmlValue)
library(httr)
library(RCurl)
con = url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en")
htmlCode = readLines(con)
close(con)
library(httr)
library(RCurl)
con = url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en")
htmlCode = readLines(con)
close(con)
library(httr)
library(RCurl)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html2 = GET(url)
content2 = content(html2,as="text")
library(rhdf5)
created = h5createFile("example.h5")
created
created = h5createGroup("example.5","foo")
created = h5createGroup("example.5","baa")
created = h5createGroup("example.5","foo/foobaa")
h5ls("example.5")
library(rhdf5)
created = h5createGroup("example.5","foo")
created = h5createGroup("example.5","baa")
created = h5createGroup("example.5","foo/foobaa")
h5ls("example.5")
created = h5createGroup("example.h5","foo")
created = h5createGroup("example.h5","baa")
created = h5createGroup("example.h5","foo/foobaa")
h5ls("example.h5")
ucscDb <- dbConnect(MySQL(),user="genome",host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDb);
library(RMySQL)
ucscDb <- dbConnect(MySQL(),user="genome",host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDb);
library(RMySQL)
ucscDb <- dbConnect(MySQL(),user="genome",host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;")
dbDisconnect(ucscDb)
setwd("~/Coursera")
#1.Merges the training and the test sets to create one data set.
features<- read.table("features.txt")
xtest<- read.table("./test/X_test.txt")
ytest<- read.table("./test/Y_test.txt")
stest<- read.table("./test/subject_test.txt")
colnames(ytest)<- "activity_id"
colnames(stest)<- "subject_id"
colnames(xtest)<- features[,2]
xtrain<- read.table("./train/X_train.txt")
ytrain<- read.table("./train/Y_train.txt")
strain<- read.table("./train/subject_train.txt")
colnames(ytrain)<- "activity_id"
colnames(strain)<- "subject_id"
colnames(xtrain)<- features[,2]
newx<- rbind(xtest,xtrain)
newy<- rbind(ytest,ytrain)
news<- rbind(stest,strain)
df<- cbind(news, newx)
df<- cbind(df, newy)
#2.Extracts only the measurements on the mean and standard deviation for each measurement
rexp_pattern<- "(mean\\(\\)|std\\(\\))"
subset_match<- grep(rexp_pattern, features[,2])
subset_df<- df[ ,subset_match]
head(subset_df,2)
subset_match[6]
subset_match
subset_match[40]
df[,6]
head(df[,6],2)
head(df[,6])
subset_match
